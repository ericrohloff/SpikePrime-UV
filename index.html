<!DOCTYPE html>
<html lang="en">
    <head>
        <title>UV</title>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0" />

        <!-- PyScript CSS -->
        <link
            rel="stylesheet"
            href="https://pyscript.net/releases/2024.7.1/core.css"
        />

        <!-- This script tag bootstraps PyScript -->
        <script
            type="module"
            src="https://pyscript.net/releases/2024.7.1/core.js"
        ></script>
        <link rel="stylesheet" href="styles.css" />
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0/dist/chartjs-adapter-moment.min.js"></script>
    </head>
    <body>
        <script
            type="mpy"
            src="./main.py"
            config="./pyscript.toml"
            async
        ></script>
        <script src="app.js"></script>

        <h1>UV Index Activity</h1>
        <p>
            You and your friends are planning to play frisbee in the park. You
            need to know the UV index to make sure you are safe and when the
            best time to play is between 9am and 5pm. You have a Spike Prime and
            a UV sensor to help you with this task. You will use the UV sensor
            to get the UV index and compare it to the local weather station UV
            index. Then use Python to analyze the data to find the best time to
            play with your friends.
        </p>

        <h2>Connect to Spike and Pico</h2>
        <p>
            First connect up to the Spike Prime in order to communicate to the
            RoboPico. This will let us grab data on when the best time to play
            frisbee is.
        </p>
        <button id="connect">connect up</button>
        <button id="library">load BLE library</button>
        <progress id="progress" value="0" max="100">0%</progress> <br /><br />
        <select name="files" id="files"></select>
        <button id="upload">Grab remote code</button>
        <button id="clear">Clear</button>
        <button id="test">BLE Test Code</button> <br /><br />
        <script id="mpCode" type="mpy-editor" env="ble"></script>
        <div id="repl"></div>

        <h2>Get UV Data</h2>
        <p>
            Now that we have the UV data running. We need to compare it to the
            the local UV data from the nearest weather station. To do this we
            will use data from the EPA API. This will give use the UV index for
            the local area. Input the town and state to get the UV index of
            where you will play frisbee.
        </p>
        <form id="locationForm">
            <label for="city">City:</label>
            <input type="text" id="city" name="city" required />
            <label for="state">State:</label>
            <input type="text" id="state" name="state" required />
            <button type="submit">Get UV Index</button>
        </form>
        <canvas id="uvChart" width="400" height="200"></canvas>

        <h2>Data Science Go!</h2>
        <p>
            Now that we have the UV data from the local weather station and the
            UV data from the Spike Prime. We can compare the two data sets to
            see how accurate the Spike Prime is and see if the UV index matches
            the forecasted UV index. First add the sensor data to the graph
            above using the "Add Sensor Data" button. Next start playing with
            the data using the "Start Analyzing" button to find the best time to
            play frisbee.
        </p>
        <button id="get_sensor_data">Add Sensor Data</button>
        <button id="to_python">Start Analyzing</button>
        <script type="py-editor" config="matplotlib.toml">
            import matplotlib.pyplot as plt
            import matplotlib.tri as tri
            import numpy as np

            from pyscript import display

            # First create the x and y coordinates of the points.
            n_angles = 36
            n_radii = 8
            min_radius = 0.25
            radii = np.linspace(min_radius, 0.95, n_radii)

            angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)
            angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
            angles[:, 1::2] += np.pi / n_angles

            x = (radii * np.cos(angles)).flatten()
            y = (radii * np.sin(angles)).flatten()
            z = (np.cos(radii) * np.cos(3 * angles)).flatten()

            # Create the Triangulation; no triangles so Delaunay triangulation created.
            triang = tri.Triangulation(x, y)

            # Mask off unwanted triangles.
            triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),
                                        y[triang.triangles].mean(axis=1))
                            < min_radius)

            fig1, ax1 = plt.subplots()
            ax1.set_aspect('equal')
            tpc = ax1.tripcolor(triang, z, shading='flat')
            fig1.colorbar(tpc)
            ax1.set_title('tripcolor of Delaunay triangulation, flat shading')

            display(fig1, target="mpl")
        </script>
        <div id="mpl"></div>
    </body>
</html>
